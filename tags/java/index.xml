<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on</title><link>https://www.s9a.me/tags/java/</link><description>Recent content in java on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 06 Jan 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://www.s9a.me/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Why you should not use null as a method parameter</title><link>https://www.s9a.me/posts/2020-01-06-design-oop-avoid-using-nulls-method-argument/</link><pubDate>Mon, 06 Jan 2020 00:00:00 +0000</pubDate><guid>https://www.s9a.me/posts/2020-01-06-design-oop-avoid-using-nulls-method-argument/</guid><description>Object Oriented concept was first introduced with Lisp in the late 1950s. Lisp has atoms and attributes, where the atoms represented an real world object. OOP has evolved quite a bit after that. SOLID design principle were introduced that helped us craft a better software. I will not go in details of how these principles help us, there is already lot of material out there. Instead I&amp;rsquo;ll focus on some mistakes we do while implementing these patterns.</description></item><item><title>Convert String to title case in Java using Streams</title><link>https://www.s9a.me/java/convert-string-title-case-java-streams/</link><pubDate>Tue, 10 Dec 2019 00:00:00 +0000</pubDate><guid>https://www.s9a.me/java/convert-string-title-case-java-streams/</guid><description>Title case is capitalized first character of each word. That means, we have to do this:
Break at word boundaries Capitalize the first character and lowercase the others Join again at word boundaries. public String toTitleCase(String str) { final String wordBoundary = &amp;#34; &amp;#34;; return Arrays.stream(str.split(wordBoundary)) .map(it -&amp;gt; it.substring(0, 1).toUpperCase() + it.substring(1, it.length()).toLowerCase()) .collect(Collectors.joining(wordBoundary)); } Let&amp;rsquo;s see it in actions:
Roughing It =&amp;gt; Roughing It PRIde AnD PrejudICE =&amp;gt; Pride And Prejudice a tale of two Cities =&amp;gt; A Tale Of Two Cities</description></item><item><title>Insert, Index document in Elasticsearch using Java</title><link>https://www.s9a.me/elasticsearch/insert-index-document-elasticsearch-java/</link><pubDate>Wed, 27 Nov 2019 00:00:00 +0000</pubDate><guid>https://www.s9a.me/elasticsearch/insert-index-document-elasticsearch-java/</guid><description>In this article we will see how to insert a document in Elasticsearch using the High Level Client provided by Elasticsearch.
Prepare the Index Request Elasticsearch client accepts IndexRequest to insert documents. Two required details for this request are:
Name of the index Document source Everything else can take default value. We will stick to the easy path to create our very first document and explore other optional arguments later.</description></item><item><title>Search Elasticsearch from Java using High Level Client</title><link>https://www.s9a.me/elasticsearch/search-match-all-from-java-using-high-level-client/</link><pubDate>Tue, 26 Nov 2019 00:00:00 +0000</pubDate><guid>https://www.s9a.me/elasticsearch/search-match-all-from-java-using-high-level-client/</guid><description>In [the last post]({% post_url elasticsearch/2019-11-25-connecting-to-elasticsearch-from-java %}) we saw how to connect to Elasticsearch using the High Level Client.
match_all Query using Java client The client provides many high level methods to build an Elasticsearch query. To keep it simple, let&amp;rsquo;s see how to construct a simple match_all query:
SearchRequest request = new SearchRequest(&amp;#34;online&amp;#34;); // -- 1 SearchSourceBuilder builder = new SearchSourceBuilder(); // -- 2 builder.query(QueryBuilders.matchAllQuery()); request.source(builder); // -- 3 Parameter to the constructor is the index you want to query, this can be left empty and all the indices will be queried SearchSourceBuilder is used to create a search request.</description></item><item><title>Connect to Elasticsearch using Java High Level Client</title><link>https://www.s9a.me/elasticsearch/connect-from-java-using-high-level-client/</link><pubDate>Mon, 25 Nov 2019 00:00:00 +0000</pubDate><guid>https://www.s9a.me/elasticsearch/connect-from-java-using-high-level-client/</guid><description>Elasticsearch provides a client to conveniently connect with Elasticsearch. Create a Maven project and add the following maven dependency:
Add Maven Dependency &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.elasticsearch.client&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;elasticsearch-rest-high-level-client&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;7.3.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Set Up connection with Elasticsearch Elasticsearch maintains 2 clients - Low Level Client and High Level Client. It is recommended to use the High Level Client to query and index documents in Elasticsearch. You can create connection to Elasticsearch like this:
RestHighLevelClient client = new RestHighLevelClient( RestClient.</description></item><item><title>Spring REST - Extract URL Path Variables</title><link>https://www.s9a.me/java/spring/extract-use-parse-url-path-data-variable/</link><pubDate>Sun, 24 Nov 2019 00:00:00 +0000</pubDate><guid>https://www.s9a.me/java/spring/extract-use-parse-url-path-data-variable/</guid><description>REST APIs have resource names and resource id present in the URL path unlike a traditional web API. This article focuses on how to extract that information and use it.
Take a typical REST URL:
GET https://api.bookstore.com/authors/twain-mark/books/roughing-it Here, the name of the author and the name of the book are inside the book and not part of the request body or query parameters. This is a standard practice while developing REST APIs.</description></item><item><title>Spring - Read Http Request headers</title><link>https://www.s9a.me/java/spring/request-headers-in-spring-rest/</link><pubDate>Sat, 23 Nov 2019 00:00:00 +0000</pubDate><guid>https://www.s9a.me/java/spring/request-headers-in-spring-rest/</guid><description>In the previous article we saw how to use request parameters and request body of a request. In this article we will see how to use the request headers.
The request headers can be accessed using the @RequestHeader attribute.
@RequestMapping(&amp;#34;/greeting&amp;#34;) public ResponseEntity&amp;lt;String&amp;gt; greeting(@RequestHeader(&amp;#34;Accept-Language&amp;#34;) String language, @RequestHeader(&amp;#34;Content-Type&amp;#34;) String contentType) { // do something with the headers return new ResponseEntity&amp;lt;String&amp;gt;(String.format(&amp;#34;Language: %s, Content Type: %s&amp;#34;, language, contentType), HttpStatus.OK); } Note that the name of the header field is case insensitive.</description></item><item><title>Creating CSV from Strings in Java</title><link>https://www.s9a.me/java/creating-csv-from-strings/</link><pubDate>Sun, 17 Nov 2019 00:00:00 +0000</pubDate><guid>https://www.s9a.me/java/creating-csv-from-strings/</guid><description>Earlier in Java 7, you needed a StringBuilder to create a CSV from list. From Java 8 onwards, there are multiple ways to achieve this depending on the task in hand.
1. Using the String.join method The String class has a join method that take a delimiter.
List&amp;lt;String&amp;gt; tokens = Arrays.asList(&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;, &amp;#34;three&amp;#34;); String joined = String.join(&amp;#34;,&amp;#34;, tokens); System.out.println(joined); // --output -- // one,two,three 2. Using the StringJoiner Another similar way to achieve this is using the StringJoiner class.</description></item><item><title>Running in Pig in Local Mode in Java</title><link>https://www.s9a.me/posts/2018-08-01-running-hadoop/</link><pubDate>Wed, 01 Aug 2018 07:11:02 +0000</pubDate><guid>https://www.s9a.me/posts/2018-08-01-running-hadoop/</guid><description>Overview of steps Create a new maven project Add Hadoop and Pig dependencies Write a small pig script to count words in a file Write a driver program that will run this pig script 1. Create a new maven project mvn archetype:generate -DgroupId=com.example -DartifactId=piglocal -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false You can now import the project in your IDE.
2. Add Hadoop and Pig dependencies Pig needs the following dependencies:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.pig&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;pig&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.17.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.</description></item><item><title>Elasticsearch Bulk API Example and Performance Comparison</title><link>https://www.s9a.me/posts/elasticsearch/2017-04-14-elasticsearch-bulk-api-example-and-performance-comparison/</link><pubDate>Fri, 14 Apr 2017 10:14:10 +0000</pubDate><guid>https://www.s9a.me/posts/elasticsearch/2017-04-14-elasticsearch-bulk-api-example-and-performance-comparison/</guid><description>Elasticsearch provides bulk operations to perform multiple operations in a single call. Bulk APIs can be accessed by hitting the _bulk endpoint. This post demonstrates the use of bulk API with Python. It assumes that you are familiar (not expert) with REST Bulk API of Elasticsearch. To keep it simple we will just consider the insertion case.
Problem Statement Before we jump into code, letâ€™s take a minute and think about the problem in hand.</description></item></channel></rss>